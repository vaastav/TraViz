{"ast":null,"code":"import * as d3 from \"d3\";\nimport * as VizLane from \"./VizLane\";\nexport var Group = function Group() {};\n\nGroup.prototype.Lanes = function () {\n  return [];\n};\n\nGroup.prototype.Events = function () {\n  return [].concat.apply([], this.Lanes().map(function (lane) {\n    return lane.Events();\n  }));\n};\n\nGroup.prototype.Spans = function () {\n  return [].concat.apply([], this.Lanes().map(function (lane) {\n    return lane.Spans();\n  }));\n};\n\nGroup.prototype.Threads = function () {\n  return [].concat.apply([], this.Lanes().map(function (lane) {\n    return lane.Threads();\n  }));\n};\n\nGroup.prototype.Processes = function () {\n  return [].concat.apply([], this.Lanes().map(function (lane) {\n    return lane.Processes();\n  }));\n};\n\nGroup.prototype.Tasks = function () {\n  return [].concat.apply([], this.Lanes().map(function (lane) {\n    return lane.Tasks();\n  }));\n};\n\nGroup.prototype.Edges = function () {\n  return [].concat.apply([], this.Lanes().map(function (lane) {\n    return lane.Edges();\n  }));\n};\n\nGroup.prototype.GC = function () {\n  return [].concat.apply([], this.Lanes().map(function (lane) {\n    return lane.GC();\n  }));\n};\n\nGroup.prototype.HDD = function () {\n  return [].concat.apply([], this.Lanes().map(function (lane) {\n    return lane.HDD();\n  }));\n};\n\nGroup.prototype.Network = function () {\n  return [].concat.apply([], this.Lanes().map(function (lane) {\n    return lane.Network();\n  }));\n};\n\nGroup.prototype.Fill = function (_) {\n  if (!arguments.length) return this.fill ? this.fill : 0;\n  this.fill = _;\n  return this;\n};\n\nGroup.prototype.Height = function (_) {\n  var s = this.Spacing();\n  if (this.Lanes().length == 0) return 0;\n  return this.Lanes().map(function (l) {\n    return l.Height();\n  }).reduce(function (a, b) {\n    return a + b + s;\n  });\n};\n\nGroup.prototype.Offset = function (_) {\n  if (!arguments.length) return this.offset ? this.offset : 0;\n  this.offset = _;\n  var spacing = this.Spacing();\n  this.Lanes().forEach(function (lane) {\n    lane.Offset(_);\n    _ += lane.Height() + spacing;\n  });\n  return this;\n};\n\nGroup.prototype.Spacing = function (_) {\n  if (!arguments.length) return this.spacing ? this.spacing : 0;\n  this.spacing = _;\n  this.Offset(this.Offset());\n  return this;\n};\n\nGroup.Scale = function (scale) {\n  return {\n    Height: function Height(group) {\n      return scale(group.Height());\n    },\n    Offset: function Offset(group) {\n      return scale(group.Offset());\n    }\n  };\n};\n\nvar ProcessGroup = function ProcessGroup(layout, process) {\n  // Save the arguments\n  this.layout = layout;\n  this.process = process; // Create the lanes\n\n  var group = this;\n  this.lanes = process.Threads().map(function (thread) {\n    return new VizLane.ThreadLane(group, thread);\n  }); // Generate a background colour for this group\n\n  this.Fill(d3.rgb(200 + Math.random() * 20, 200 + Math.random() * 20, 200 + Math.random() * 20));\n  this.lanes.forEach(function (lane) {\n    lane.Fill(group.Fill());\n  }); // Set initial spacing and offset for lanes\n\n  this.Spacing(1).Offset(0); // Save the group on the GC events\n\n  var group = this;\n  this.Events().forEach(function (evt) {\n    evt.group = group;\n  });\n  this.Spans().forEach(function (spn) {\n    spn.group = group;\n  });\n  this.GC().forEach(function (gc) {\n    gc.group = group;\n  });\n  this.Edges().filter(function (edge) {\n    return edge.parent.lane != edge.child.lane && edge.parent.group == group;\n  }).forEach(function (edge) {\n    edge.type = \"group\";\n  });\n};\n\nProcessGroup.prototype = new Group();\n\nProcessGroup.prototype.Lanes = function () {\n  return this.lanes;\n};\n\nProcessGroup.prototype.GC = function () {\n  return this.process.GCEvents();\n};\n\nvar TenantGroup = function TenantGroup(layout, tasks) {\n  this.layout = layout;\n  this.tasks = tasks; // Create the lanes\n\n  var group = this;\n  this.lanes = tasks.map(function (task) {\n    return new VizLane.TaskLane(group, task);\n  }); // Generate a background colour for this group\n\n  this.Fill(d3.rgb(200 + Math.random() * 20, 200 + Math.random() * 20, 200 + Math.random() * 20));\n  this.lanes.forEach(function (lane) {\n    lane.Fill(group.Fill());\n  }); // Set initial spacing and offset for lanes\n\n  this.Spacing(1).Offset(0); // Save the group on things\n\n  tasks.forEach(function (task) {\n    task.group = group;\n  });\n  this.HDD().forEach(function (evt) {\n    evt.group = group;\n  });\n  this.Network().forEach(function (evt) {\n    evt.group = group;\n  });\n};\n\nTenantGroup.prototype = new Group();\n\nTenantGroup.prototype.Lanes = function () {\n  return this.lanes;\n}; //var CompactProcessGroup = function(layout, process) {\n//  \n//};\n//\n//function SpanGroup(threads) {\n//  var groups = [];\n//  \n//  var makegroup = function() {\n//    var group = [];\n//    var id = groupid+\"_group\"+groups.length;\n//    group.ID = function() { return id; };\n//    group.End = function() { return group.length==0 ? 0 : group[group.length-1].End(); }\n//    group.Events = function() { return [].concat.apply([], group.map(function(span) { return span.Events(); })); };\n//    group.Spans = function() { return group; };\n//    return group;\n//  };\n//  \n//  for (var i = 0; i < numgroups; i++)\n//    groups.push(makegroup(i));\n//\n//  var affinity = {};\n//  for (var i = 0; i < threaddata.length; i++)\n//    affinity[threaddata[i].ID()] = i % numgroups;\n//  \n//  var spans = [].concat.apply([], threaddata.map(function(thread) { return thread.Spans(); }));\n//  spans.sort(function(a, b) { return a.Start() - b.Start(); });\n//  \n//  for (var i = 0; i < spans.length; i++) {\n//    var span = spans[i], spanaffinity = affinity[span.thread.ID()];\n//    for (var j = 0; j < numgroups; j++) {\n//      var k = (j + spanaffinity) % numgroups;\n//      if (groups[k].End() <= span.Start()) {\n//        groups[k].push(span);\n//        break;\n//      }\n//    }\n//  }\n//  \n//  return groups;\n//};","map":{"version":3,"sources":["/home/stolet/TraViz/traviz_frontend/src/components/Swimlane/data/VizGroup.js"],"names":["d3","VizLane","Group","prototype","Lanes","Events","concat","apply","map","lane","Spans","Threads","Processes","Tasks","Edges","GC","HDD","Network","Fill","_","arguments","length","fill","Height","s","Spacing","l","reduce","a","b","Offset","offset","spacing","forEach","Scale","scale","group","ProcessGroup","layout","process","lanes","thread","ThreadLane","rgb","Math","random","evt","spn","gc","filter","edge","parent","child","type","GCEvents","TenantGroup","tasks","task","TaskLane"],"mappings":"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","sourcesContent":["import * as d3 from \"d3\"\nimport * as VizLane from \"./VizLane\"\nexport var Group = function () { };\nGroup.prototype.Lanes = function () { return []; };\n\nGroup.prototype.Events = function () { return [].concat.apply([], this.Lanes().map(function (lane) { return lane.Events(); })); };\nGroup.prototype.Spans = function () { return [].concat.apply([], this.Lanes().map(function (lane) { return lane.Spans(); })); };\nGroup.prototype.Threads = function () { return [].concat.apply([], this.Lanes().map(function (lane) { return lane.Threads(); })); };\nGroup.prototype.Processes = function () { return [].concat.apply([], this.Lanes().map(function (lane) { return lane.Processes(); })); };\nGroup.prototype.Tasks = function () { return [].concat.apply([], this.Lanes().map(function (lane) { return lane.Tasks(); })); };\nGroup.prototype.Edges = function () { return [].concat.apply([], this.Lanes().map(function (lane) { return lane.Edges(); })); };\nGroup.prototype.GC = function () { return [].concat.apply([], this.Lanes().map(function (lane) { return lane.GC(); })); };\nGroup.prototype.HDD = function () { return [].concat.apply([], this.Lanes().map(function (lane) { return lane.HDD(); })); };\nGroup.prototype.Network = function () { return [].concat.apply([], this.Lanes().map(function (lane) { return lane.Network(); })); };\n\nGroup.prototype.Fill = function (_) { if (!arguments.length) return this.fill ? this.fill : 0; this.fill = _; return this; };\nGroup.prototype.Height = function (_) { var s = this.Spacing(); if (this.Lanes().length == 0) return 0; return this.Lanes().map(function (l) { return l.Height(); }).reduce(function (a, b) { return a + b + s; }); };\nGroup.prototype.Offset = function (_) {\n  if (!arguments.length)\n    return this.offset ? this.offset : 0;\n  this.offset = _;\n  var spacing = this.Spacing();\n  this.Lanes().forEach(function (lane) { lane.Offset(_); _ += lane.Height() + spacing; });\n  return this;\n};\nGroup.prototype.Spacing = function (_) {\n  if (!arguments.length)\n    return this.spacing ? this.spacing : 0;\n  this.spacing = _;\n  this.Offset(this.Offset());\n  return this;\n};\n\nGroup.Scale = function (scale) {\n  return {\n    Height: function (group) { return scale(group.Height()); },\n    Offset: function (group) { return scale(group.Offset()); }\n  };\n};\n\nvar ProcessGroup = function (layout, process) {\n  // Save the arguments\n  this.layout = layout;\n  this.process = process;\n\n  // Create the lanes\n  var group = this;\n  this.lanes = process.Threads().map(function (thread) { return new VizLane.ThreadLane(group, thread); });\n\n  // Generate a background colour for this group\n  this.Fill(d3.rgb(200 + Math.random() * 20, 200 + Math.random() * 20, 200 + Math.random() * 20));\n  this.lanes.forEach(function (lane) { lane.Fill(group.Fill()); });\n\n  // Set initial spacing and offset for lanes\n  this.Spacing(1).Offset(0);\n\n  // Save the group on the GC events\n  var group = this;\n  this.Events().forEach(function (evt) { evt.group = group; });\n  this.Spans().forEach(function (spn) { spn.group = group; });\n  this.GC().forEach(function (gc) { gc.group = group; });\n  this.Edges().filter(function (edge) { return edge.parent.lane != edge.child.lane && edge.parent.group == group; }).forEach(function (edge) { edge.type = \"group\"; });\n};\nProcessGroup.prototype = new Group();\nProcessGroup.prototype.Lanes = function () { return this.lanes; };\nProcessGroup.prototype.GC = function () { return this.process.GCEvents(); };\n\nvar TenantGroup = function (layout, tasks) {\n  this.layout = layout;\n  this.tasks = tasks;\n\n  // Create the lanes\n  var group = this;\n  this.lanes = tasks.map(function (task) { return new VizLane.TaskLane(group, task); });\n\n  // Generate a background colour for this group\n  this.Fill(d3.rgb(200 + Math.random() * 20, 200 + Math.random() * 20, 200 + Math.random() * 20));\n  this.lanes.forEach(function (lane) { lane.Fill(group.Fill()); });\n\n  // Set initial spacing and offset for lanes\n  this.Spacing(1).Offset(0);\n\n  // Save the group on things\n  tasks.forEach(function (task) { task.group = group; });\n  this.HDD().forEach(function (evt) { evt.group = group; });\n  this.Network().forEach(function (evt) { evt.group = group; });\n};\nTenantGroup.prototype = new Group();\nTenantGroup.prototype.Lanes = function () { return this.lanes; };\n\n//var CompactProcessGroup = function(layout, process) {\n//  \n//};\n//\n//function SpanGroup(threads) {\n//  var groups = [];\n//  \n//  var makegroup = function() {\n//    var group = [];\n//    var id = groupid+\"_group\"+groups.length;\n//    group.ID = function() { return id; };\n//    group.End = function() { return group.length==0 ? 0 : group[group.length-1].End(); }\n//    group.Events = function() { return [].concat.apply([], group.map(function(span) { return span.Events(); })); };\n//    group.Spans = function() { return group; };\n//    return group;\n//  };\n//  \n//  for (var i = 0; i < numgroups; i++)\n//    groups.push(makegroup(i));\n//\n//  var affinity = {};\n//  for (var i = 0; i < threaddata.length; i++)\n//    affinity[threaddata[i].ID()] = i % numgroups;\n//  \n//  var spans = [].concat.apply([], threaddata.map(function(thread) { return thread.Spans(); }));\n//  spans.sort(function(a, b) { return a.Start() - b.Start(); });\n//  \n//  for (var i = 0; i < spans.length; i++) {\n//    var span = spans[i], spanaffinity = affinity[span.thread.ID()];\n//    for (var j = 0; j < numgroups; j++) {\n//      var k = (j + spanaffinity) % numgroups;\n//      if (groups[k].End() <= span.Start()) {\n//        groups[k].push(span);\n//        break;\n//      }\n//    }\n//  }\n//  \n//  return groups;\n//};"]},"metadata":{},"sourceType":"module"}