{"ast":null,"code":"import identity from './identity';\n\nfunction heap_by(f) {\n  // Builds a binary heap within the specified array a[lo:hi]. The heap has the\n  // property such that the parent a[lo+i] is always less than or equal to its\n  // two children: a[lo+2*i+1] and a[lo+2*i+2].\n  function heap(a, lo, hi) {\n    var n = hi - lo,\n        i = (n >>> 1) + 1;\n\n    while (--i > 0) {\n      sift(a, i, n, lo);\n    }\n\n    return a;\n  } // Sorts the specified array a[lo:hi] in descending order, assuming it is\n  // already a heap.\n\n\n  function sort(a, lo, hi) {\n    var n = hi - lo,\n        t;\n\n    while (--n > 0) {\n      t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);\n    }\n\n    return a;\n  } // Sifts the element a[lo+i-1] down the heap, where the heap is the contiguous\n  // slice of array a[lo:lo+n]. This method can also be used to update the heap\n  // incrementally, without incurring the full cost of reconstructing the heap.\n\n\n  function sift(a, i, n, lo) {\n    var d = a[--lo + i],\n        x = f(d),\n        child;\n\n    while ((child = i << 1) <= n) {\n      if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;\n      if (x <= f(a[lo + child])) break;\n      a[lo + i] = a[lo + child];\n      i = child;\n    }\n\n    a[lo + i] = d;\n  }\n\n  heap.sort = sort;\n  return heap;\n}\n\nvar h = heap_by(identity);\nh.by = heap_by;\nexport default h;","map":null,"metadata":{},"sourceType":"module"}