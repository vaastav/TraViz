{"ast":null,"code":"// https://crossfilter.github.io/crossfilter/ v1.5.0 Copyright 2019 Mike Bostock\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.crossfilter = factory());\n})(this, function () {\n  'use strict';\n\n  var array8 = arrayUntyped,\n      array16 = arrayUntyped,\n      array32 = arrayUntyped,\n      arrayLengthen = arrayLengthenUntyped,\n      arrayWiden = arrayWidenUntyped;\n\n  if (typeof Uint8Array !== \"undefined\") {\n    array8 = function array8(n) {\n      return new Uint8Array(n);\n    };\n\n    array16 = function array16(n) {\n      return new Uint16Array(n);\n    };\n\n    array32 = function array32(n) {\n      return new Uint32Array(n);\n    };\n\n    arrayLengthen = function arrayLengthen(array, length) {\n      if (array.length >= length) return array;\n      var copy = new array.constructor(length);\n      copy.set(array);\n      return copy;\n    };\n\n    arrayWiden = function arrayWiden(array, width) {\n      var copy;\n\n      switch (width) {\n        case 16:\n          copy = array16(array.length);\n          break;\n\n        case 32:\n          copy = array32(array.length);\n          break;\n\n        default:\n          throw new Error(\"invalid array width!\");\n      }\n\n      copy.set(array);\n      return copy;\n    };\n  }\n\n  function arrayUntyped(n) {\n    var array = new Array(n),\n        i = -1;\n\n    while (++i < n) {\n      array[i] = 0;\n    }\n\n    return array;\n  }\n\n  function arrayLengthenUntyped(array, length) {\n    var n = array.length;\n\n    while (n < length) {\n      array[n++] = 0;\n    }\n\n    return array;\n  }\n\n  function arrayWidenUntyped(array, width) {\n    if (width > 32) throw new Error(\"invalid array width!\");\n    return array;\n  } // An arbitrarily-wide array of bitmasks\n\n\n  function bitarray(n) {\n    this.length = n;\n    this.subarrays = 1;\n    this.width = 8;\n    this.masks = {\n      0: 0\n    };\n    this[0] = array8(n);\n  }\n\n  bitarray.prototype.lengthen = function (n) {\n    var i, len;\n\n    for (i = 0, len = this.subarrays; i < len; ++i) {\n      this[i] = arrayLengthen(this[i], n);\n    }\n\n    this.length = n;\n  }; // Reserve a new bit index in the array, returns {offset, one}\n\n\n  bitarray.prototype.add = function () {\n    var m, w, one, i, len;\n\n    for (i = 0, len = this.subarrays; i < len; ++i) {\n      m = this.masks[i];\n      w = this.width - 32 * i; // isolate the rightmost zero bit and return it as an unsigned int of 32 bits, if NaN or -1, return a 0 \n\n      one = (~m & m + 1) >>> 0;\n\n      if (w >= 32 && !one) {\n        continue;\n      }\n\n      if (w < 32 && one & 1 << w) {\n        // widen this subarray\n        this[i] = arrayWiden(this[i], w <<= 1);\n        this.width = 32 * i + w;\n      }\n\n      this.masks[i] |= one;\n      return {\n        offset: i,\n        one: one\n      };\n    } // add a new subarray\n\n\n    this[this.subarrays] = array8(this.length);\n    this.masks[this.subarrays] = 1;\n    this.width += 8;\n    return {\n      offset: this.subarrays++,\n      one: 1\n    };\n  }; // Copy record from index src to index dest\n\n\n  bitarray.prototype.copy = function (dest, src) {\n    var i, len;\n\n    for (i = 0, len = this.subarrays; i < len; ++i) {\n      this[i][dest] = this[i][src];\n    }\n  }; // Truncate the array to the given length\n\n\n  bitarray.prototype.truncate = function (n) {\n    var i, len;\n\n    for (i = 0, len = this.subarrays; i < len; ++i) {\n      for (var j = this.length - 1; j >= n; j--) {\n        this[i][j] = 0;\n      }\n    }\n\n    this.length = n;\n  }; // Checks that all bits for the given index are 0\n\n\n  bitarray.prototype.zero = function (n) {\n    var i, len;\n\n    for (i = 0, len = this.subarrays; i < len; ++i) {\n      if (this[i][n]) {\n        return false;\n      }\n    }\n\n    return true;\n  }; // Checks that all bits for the given index are 0 except for possibly one\n\n\n  bitarray.prototype.zeroExcept = function (n, offset, zero) {\n    var i, len;\n\n    for (i = 0, len = this.subarrays; i < len; ++i) {\n      if (i === offset ? this[i][n] & zero : this[i][n]) {\n        return false;\n      }\n    }\n\n    return true;\n  }; // Checks that all bits for the given index are 0 except for the specified mask.\n  // The mask should be an array of the same size as the filter subarrays width.\n\n\n  bitarray.prototype.zeroExceptMask = function (n, mask) {\n    var i, len;\n\n    for (i = 0, len = this.subarrays; i < len; ++i) {\n      if (this[i][n] & mask[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }; // Checks that only the specified bit is set for the given index\n\n\n  bitarray.prototype.only = function (n, offset, one) {\n    var i, len;\n\n    for (i = 0, len = this.subarrays; i < len; ++i) {\n      if (this[i][n] != (i === offset ? one : 0)) {\n        return false;\n      }\n    }\n\n    return true;\n  }; // Checks that only the specified bit is set for the given index except for possibly one other\n\n\n  bitarray.prototype.onlyExcept = function (n, offset, zero, onlyOffset, onlyOne) {\n    var mask;\n    var i, len;\n\n    for (i = 0, len = this.subarrays; i < len; ++i) {\n      mask = this[i][n];\n      if (i === offset) mask &= zero;\n\n      if (mask != (i === onlyOffset ? onlyOne : 0)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  var xfilterArray = {\n    array8: arrayUntyped,\n    array16: arrayUntyped,\n    array32: arrayUntyped,\n    arrayLengthen: arrayLengthenUntyped,\n    arrayWiden: arrayWidenUntyped,\n    bitarray: bitarray\n  };\n\n  var filterExact = function filterExact(bisect, value) {\n    return function (values) {\n      var n = values.length;\n      return [bisect.left(values, value, 0, n), bisect.right(values, value, 0, n)];\n    };\n  };\n\n  var filterRange = function filterRange(bisect, range) {\n    var min = range[0],\n        max = range[1];\n    return function (values) {\n      var n = values.length;\n      return [bisect.left(values, min, 0, n), bisect.left(values, max, 0, n)];\n    };\n  };\n\n  var filterAll = function filterAll(values) {\n    return [0, values.length];\n  };\n\n  var xfilterFilter = {\n    filterExact: filterExact,\n    filterRange: filterRange,\n    filterAll: filterAll\n  };\n\n  var cr_identity = function cr_identity(d) {\n    return d;\n  };\n\n  var cr_null = function cr_null() {\n    return null;\n  };\n\n  var cr_zero = function cr_zero() {\n    return 0;\n  };\n\n  function heap_by(f) {\n    // Builds a binary heap within the specified array a[lo:hi]. The heap has the\n    // property such that the parent a[lo+i] is always less than or equal to its\n    // two children: a[lo+2*i+1] and a[lo+2*i+2].\n    function heap(a, lo, hi) {\n      var n = hi - lo,\n          i = (n >>> 1) + 1;\n\n      while (--i > 0) {\n        sift(a, i, n, lo);\n      }\n\n      return a;\n    } // Sorts the specified array a[lo:hi] in descending order, assuming it is\n    // already a heap.\n\n\n    function sort(a, lo, hi) {\n      var n = hi - lo,\n          t;\n\n      while (--n > 0) {\n        t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);\n      }\n\n      return a;\n    } // Sifts the element a[lo+i-1] down the heap, where the heap is the contiguous\n    // slice of array a[lo:lo+n]. This method can also be used to update the heap\n    // incrementally, without incurring the full cost of reconstructing the heap.\n\n\n    function sift(a, i, n, lo) {\n      var d = a[--lo + i],\n          x = f(d),\n          child;\n\n      while ((child = i << 1) <= n) {\n        if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;\n        if (x <= f(a[lo + child])) break;\n        a[lo + i] = a[lo + child];\n        i = child;\n      }\n\n      a[lo + i] = d;\n    }\n\n    heap.sort = sort;\n    return heap;\n  }\n\n  var h = heap_by(cr_identity);\n  h.by = heap_by;\n\n  function heapselect_by(f) {\n    var heap = h.by(f); // Returns a new array containing the top k elements in the array a[lo:hi].\n    // The returned array is not sorted, but maintains the heap property. If k is\n    // greater than hi - lo, then fewer than k elements will be returned. The\n    // order of elements in a is unchanged by this operation.\n\n    function heapselect(a, lo, hi, k) {\n      var queue = new Array(k = Math.min(hi - lo, k)),\n          min,\n          i,\n          d;\n\n      for (i = 0; i < k; ++i) {\n        queue[i] = a[lo++];\n      }\n\n      heap(queue, 0, k);\n\n      if (lo < hi) {\n        min = f(queue[0]);\n\n        do {\n          if (f(d = a[lo]) > min) {\n            queue[0] = d;\n            min = f(heap(queue, 0, k)[0]);\n          }\n        } while (++lo < hi);\n      }\n\n      return queue;\n    }\n\n    return heapselect;\n  }\n\n  var h$1 = heapselect_by(cr_identity);\n  h$1.by = heapselect_by; // assign the raw function to the export as well\n\n  function bisect_by(f) {\n    // Locate the insertion point for x in a to maintain sorted order. The\n    // arguments lo and hi may be used to specify a subset of the array which\n    // should be considered; by default the entire array is used. If x is already\n    // present in a, the insertion point will be before (to the left of) any\n    // existing entries. The return value is suitable for use as the first\n    // argument to `array.splice` assuming that a is already sorted.\n    //\n    // The returned insertion point i partitions the array a into two halves so\n    // that all v < x for v in a[lo:i] for the left side and all v >= x for v in\n    // a[i:hi] for the right side.\n    function bisectLeft(a, x, lo, hi) {\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (f(a[mid]) < x) lo = mid + 1;else hi = mid;\n      }\n\n      return lo;\n    } // Similar to bisectLeft, but returns an insertion point which comes after (to\n    // the right of) any existing entries of x in a.\n    //\n    // The returned insertion point i partitions the array into two halves so that\n    // all v <= x for v in a[lo:i] for the left side and all v > x for v in\n    // a[i:hi] for the right side.\n\n\n    function bisectRight(a, x, lo, hi) {\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (x < f(a[mid])) hi = mid;else lo = mid + 1;\n      }\n\n      return lo;\n    }\n\n    bisectRight.right = bisectRight;\n    bisectRight.left = bisectLeft;\n    return bisectRight;\n  }\n\n  var bisect = bisect_by(cr_identity);\n  bisect.by = bisect_by; // assign the raw function to the export as well\n\n  var permute = function permute(array, index, deep) {\n    for (var i = 0, n = index.length, copy = deep ? JSON.parse(JSON.stringify(array)) : new Array(n); i < n; ++i) {\n      copy[i] = array[index[i]];\n    }\n\n    return copy;\n  };\n\n  var reduceIncrement = function reduceIncrement(p) {\n    return p + 1;\n  };\n\n  var reduceDecrement = function reduceDecrement(p) {\n    return p - 1;\n  };\n\n  var reduceAdd = function reduceAdd(f) {\n    return function (p, v) {\n      return p + +f(v);\n    };\n  };\n\n  var reduceSubtract = function reduceSubtract(f) {\n    return function (p, v) {\n      return p - f(v);\n    };\n  };\n\n  var xfilterReduce = {\n    reduceIncrement: reduceIncrement,\n    reduceDecrement: reduceDecrement,\n    reduceAdd: reduceAdd,\n    reduceSubtract: reduceSubtract\n  };\n\n  function deep(t, e, i, n, r) {\n    for (r in n = (i = i.split(\".\")).splice(-1, 1), i) {\n      e = e[i[r]] = e[i[r]] || {};\n    }\n\n    return t(e, n);\n  } // Note(cg): result was previsouly using lodash.result, not ESM compatible.\n\n\n  var get = function get(obj, prop) {\n    var value = obj[prop];\n    return typeof value === 'function' ? value.call(obj) : value;\n  };\n  /**\n   * get value of object at a deep path.\n   * if the resolved value is a function,\n   * it's invoked with the `this` binding of \n   * its parent object and its result is returned. \n   *  \n   * @param  {Object} obj  the object (e.g. { 'a': [{ 'b': { 'c1': 3, 'c2': 4} }], 'd': {e:1} }; )\n   * @param  {String} path deep path (e.g. `d.e`` or `a[0].b.c1`. Dot notation (a.0.b)is also supported)\n   * @return {Any}      the resolved value\n   */\n\n\n  var reg = /\\[([\\w\\d]+)\\]/g;\n\n  var result = function result(obj, path) {\n    return deep(get, obj, path.replace(reg, '.$1'));\n  }; // constants\n\n\n  var REMOVED_INDEX = -1;\n  crossfilter.heap = h;\n  crossfilter.heapselect = h$1;\n  crossfilter.bisect = bisect;\n  crossfilter.permute = permute;\n\n  function crossfilter() {\n    var crossfilter = {\n      add: add,\n      remove: removeData,\n      dimension: dimension,\n      groupAll: groupAll,\n      size: size,\n      all: all,\n      allFiltered: allFiltered,\n      onChange: onChange,\n      isElementFiltered: isElementFiltered\n    };\n    var data = [],\n        // the records\n    n = 0,\n        // the number of records; data.length\n    filters,\n        // 1 is filtered out\n    filterListeners = [],\n        // when the filters change\n    dataListeners = [],\n        // when data is added\n    removeDataListeners = [],\n        // when data is removed\n    callbacks = [];\n    filters = new xfilterArray.bitarray(0); // Adds the specified new records to this crossfilter.\n\n    function add(newData) {\n      var n0 = n,\n          n1 = newData.length; // If there's actually new data to add…\n      // Merge the new data into the existing data.\n      // Lengthen the filter bitset to handle the new records.\n      // Notify listeners (dimensions and groups) that new data is available.\n\n      if (n1) {\n        data = data.concat(newData);\n        filters.lengthen(n += n1);\n        dataListeners.forEach(function (l) {\n          l(newData, n0, n1);\n        });\n        triggerOnChange('dataAdded');\n      }\n\n      return crossfilter;\n    } // Removes all records that match the current filters, or if a predicate function is passed,\n    // removes all records matching the predicate (ignoring filters).\n\n\n    function removeData(predicate) {\n      var // Mapping from old record indexes to new indexes (after records removed)\n      newIndex = new Array(n),\n          removed = [],\n          usePred = typeof predicate === 'function',\n          shouldRemove = function shouldRemove(i) {\n        return usePred ? predicate(data[i], i) : filters.zero(i);\n      };\n\n      for (var index1 = 0, index2 = 0; index1 < n; ++index1) {\n        if (shouldRemove(index1)) {\n          removed.push(index1);\n          newIndex[index1] = REMOVED_INDEX;\n        } else {\n          newIndex[index1] = index2++;\n        }\n      } // Remove all matching records from groups.\n\n\n      filterListeners.forEach(function (l) {\n        l(-1, -1, [], removed, true);\n      }); // Update indexes.\n\n      removeDataListeners.forEach(function (l) {\n        l(newIndex);\n      }); // Remove old filters and data by overwriting.\n\n      for (var index3 = 0, index4 = 0; index3 < n; ++index3) {\n        if (newIndex[index3] !== REMOVED_INDEX) {\n          if (index3 !== index4) filters.copy(index4, index3), data[index4] = data[index3];\n          ++index4;\n        }\n      }\n\n      data.length = n = index4;\n      filters.truncate(index4);\n      triggerOnChange('dataRemoved');\n    }\n\n    function maskForDimensions(dimensions) {\n      var n,\n          d,\n          len,\n          id,\n          mask = Array(filters.subarrays);\n\n      for (n = 0; n < filters.subarrays; n++) {\n        mask[n] = ~0;\n      }\n\n      for (d = 0, len = dimensions.length; d < len; d++) {\n        // The top bits of the ID are the subarray offset and the lower bits are the bit\n        // offset of the \"one\" mask.\n        id = dimensions[d].id();\n        mask[id >> 7] &= ~(0x1 << (id & 0x3f));\n      }\n\n      return mask;\n    } // Return true if the data element at index i is filtered IN.\n    // Optionally, ignore the filters of any dimensions in the ignore_dimensions list.\n\n\n    function isElementFiltered(i, ignore_dimensions) {\n      var mask = maskForDimensions(ignore_dimensions || []);\n      return filters.zeroExceptMask(i, mask);\n    } // Adds a new dimension with the specified value accessor function.\n\n\n    function dimension(value, iterable) {\n      if (typeof value === 'string') {\n        var accessorPath = value;\n\n        value = function value(d) {\n          return result(d, accessorPath);\n        };\n      }\n\n      var dimension = {\n        filter: filter,\n        filterExact: filterExact,\n        filterRange: filterRange,\n        filterFunction: filterFunction,\n        filterAll: filterAll,\n        currentFilter: currentFilter,\n        hasCurrentFilter: hasCurrentFilter,\n        top: top,\n        bottom: bottom,\n        group: group,\n        groupAll: groupAll,\n        dispose: dispose,\n        remove: dispose,\n        // for backwards-compatibility\n        accessor: value,\n        id: function id() {\n          return _id;\n        }\n      };\n\n      var one,\n          // lowest unset bit as mask, e.g., 00001000\n      zero,\n          // inverted one, e.g., 11110111\n      offset,\n          // offset into the filters arrays\n      _id,\n          // unique ID for this dimension (reused when dimensions are disposed)\n      values,\n          // sorted, cached array\n      index,\n          // maps sorted value index -> record index (in data)\n      newValues,\n          // temporary array storing newly-added values\n      newIndex,\n          // temporary array storing newly-added index\n      iterablesIndexCount,\n          iterablesIndexFilterStatus,\n          iterablesEmptyRows = [],\n          sortRange = function sortRange(n) {\n        return cr_range(n).sort(function (A, B) {\n          var a = newValues[A],\n              b = newValues[B];\n          return a < b ? -1 : a > b ? 1 : A - B;\n        });\n      },\n          refilter = xfilterFilter.filterAll,\n          // for recomputing filter\n      refilterFunction,\n          // the custom filter function in use\n      filterValue,\n          // the value used for filtering (value, array, function or undefined)\n      filterValuePresent,\n          // true if filterValue contains something\n      indexListeners = [],\n          // when data is added\n      dimensionGroups = [],\n          lo0 = 0,\n          hi0 = 0,\n          t = 0,\n          k; // Updating a dimension is a two-stage process. First, we must update the\n      // associated filters for the newly-added records. Once all dimensions have\n      // updated their filters, the groups are notified to update.\n\n\n      dataListeners.unshift(preAdd);\n      dataListeners.push(postAdd);\n      removeDataListeners.push(removeData); // Add a new dimension in the filter bitmap and store the offset and bitmask.\n\n      var tmp = filters.add();\n      offset = tmp.offset;\n      one = tmp.one;\n      zero = ~one; // Create a unique ID for the dimension\n      // IDs will be re-used if dimensions are disposed.\n      // For internal use the ID is the subarray offset shifted left 7 bits or'd with the\n      // bit offset of the set bit in the dimension's \"one\" mask.\n\n      _id = offset << 7 | Math.log(one) / Math.log(2);\n      preAdd(data, 0, n);\n      postAdd(data, 0, n); // Incorporates the specified new records into this dimension.\n      // This function is responsible for updating filters, values, and index.\n\n      function preAdd(newData, n0, n1) {\n        var newIterablesIndexCount, newIterablesIndexFilterStatus;\n\n        if (iterable) {\n          // Count all the values\n          t = 0;\n          j = 0;\n          k = [];\n\n          for (var i0 = 0; i0 < newData.length; i0++) {\n            for (j = 0, k = value(newData[i0]); j < k.length; j++) {\n              t++;\n            }\n          }\n\n          newValues = [];\n          newIterablesIndexCount = cr_range(newData.length);\n          newIterablesIndexFilterStatus = cr_index(t, 1);\n          var unsortedIndex = cr_range(t);\n\n          for (var l = 0, index1 = 0; index1 < newData.length; index1++) {\n            k = value(newData[index1]); //\n\n            if (!k.length) {\n              newIterablesIndexCount[index1] = 0;\n              iterablesEmptyRows.push(index1 + n0);\n              continue;\n            }\n\n            newIterablesIndexCount[index1] = k.length;\n\n            for (j = 0; j < k.length; j++) {\n              newValues.push(k[j]);\n              unsortedIndex[l] = index1;\n              l++;\n            }\n          } // Create the Sort map used to sort both the values and the valueToData indices\n\n\n          var sortMap = sortRange(t); // Use the sortMap to sort the newValues\n\n          newValues = permute(newValues, sortMap); // Use the sortMap to sort the unsortedIndex map\n          // newIndex should be a map of sortedValue -> crossfilterData\n\n          newIndex = permute(unsortedIndex, sortMap);\n        } else {\n          // Permute new values into natural order using a standard sorted index.\n          newValues = newData.map(value);\n          newIndex = sortRange(n1);\n          newValues = permute(newValues, newIndex);\n        } // Bisect newValues to determine which new records are selected.\n\n\n        var bounds = refilter(newValues),\n            lo1 = bounds[0],\n            hi1 = bounds[1];\n        var index2, index3, index4;\n\n        if (iterable) {\n          n1 = t;\n\n          if (refilterFunction) {\n            for (index2 = 0; index2 < n1; ++index2) {\n              if (!refilterFunction(newValues[index2], index2)) {\n                if (--newIterablesIndexCount[newIndex[index2]] === 0) {\n                  filters[offset][newIndex[index2] + n0] |= one;\n                }\n\n                newIterablesIndexFilterStatus[index2] = 1;\n              }\n            }\n          } else {\n            for (index3 = 0; index3 < lo1; ++index3) {\n              if (--newIterablesIndexCount[newIndex[index3]] === 0) {\n                filters[offset][newIndex[index3] + n0] |= one;\n              }\n\n              newIterablesIndexFilterStatus[index3] = 1;\n            }\n\n            for (index4 = hi1; index4 < n1; ++index4) {\n              if (--newIterablesIndexCount[newIndex[index4]] === 0) {\n                filters[offset][newIndex[index4] + n0] |= one;\n              }\n\n              newIterablesIndexFilterStatus[index4] = 1;\n            }\n          }\n        } else {\n          if (refilterFunction) {\n            for (index2 = 0; index2 < n1; ++index2) {\n              if (!refilterFunction(newValues[index2], index2)) {\n                filters[offset][newIndex[index2] + n0] |= one;\n              }\n            }\n          } else {\n            for (index3 = 0; index3 < lo1; ++index3) {\n              filters[offset][newIndex[index3] + n0] |= one;\n            }\n\n            for (index4 = hi1; index4 < n1; ++index4) {\n              filters[offset][newIndex[index4] + n0] |= one;\n            }\n          }\n        } // If this dimension previously had no data, then we don't need to do the\n        // more expensive merge operation; use the new values and index as-is.\n\n\n        if (!n0) {\n          values = newValues;\n          index = newIndex;\n          iterablesIndexCount = newIterablesIndexCount;\n          iterablesIndexFilterStatus = newIterablesIndexFilterStatus;\n          lo0 = lo1;\n          hi0 = hi1;\n          return;\n        }\n\n        var oldValues = values,\n            oldIndex = index,\n            oldIterablesIndexFilterStatus = iterablesIndexFilterStatus,\n            old_n0,\n            i1 = 0;\n        i0 = 0;\n\n        if (iterable) {\n          old_n0 = n0;\n          n0 = oldValues.length;\n          n1 = t;\n        } // Otherwise, create new arrays into which to merge new and old.\n\n\n        values = iterable ? new Array(n0 + n1) : new Array(n);\n        index = iterable ? new Array(n0 + n1) : cr_index(n, n);\n        if (iterable) iterablesIndexFilterStatus = cr_index(n0 + n1, 1); // Concatenate the newIterablesIndexCount onto the old one.\n\n        if (iterable) {\n          var oldiiclength = iterablesIndexCount.length;\n          iterablesIndexCount = xfilterArray.arrayLengthen(iterablesIndexCount, n);\n\n          for (var j = 0; j + oldiiclength < n; j++) {\n            iterablesIndexCount[j + oldiiclength] = newIterablesIndexCount[j];\n          }\n        } // Merge the old and new sorted values, and old and new index.\n\n\n        var index5 = 0;\n\n        for (; i0 < n0 && i1 < n1; ++index5) {\n          if (oldValues[i0] < newValues[i1]) {\n            values[index5] = oldValues[i0];\n            if (iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n            index[index5] = oldIndex[i0++];\n          } else {\n            values[index5] = newValues[i1];\n            if (iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n            index[index5] = newIndex[i1++] + (iterable ? old_n0 : n0);\n          }\n        } // Add any remaining old values.\n\n\n        for (; i0 < n0; ++i0, ++index5) {\n          values[index5] = oldValues[i0];\n          if (iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n          index[index5] = oldIndex[i0];\n        } // Add any remaining new values.\n\n\n        for (; i1 < n1; ++i1, ++index5) {\n          values[index5] = newValues[i1];\n          if (iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n          index[index5] = newIndex[i1] + (iterable ? old_n0 : n0);\n        } // Bisect again to recompute lo0 and hi0.\n\n\n        bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];\n      } // When all filters have updated, notify index listeners of the new values.\n\n\n      function postAdd(newData, n0, n1) {\n        indexListeners.forEach(function (l) {\n          l(newValues, newIndex, n0, n1);\n        });\n        newValues = newIndex = null;\n      }\n\n      function removeData(reIndex) {\n        if (iterable) {\n          for (var i0 = 0, i1 = 0; i0 < iterablesEmptyRows.length; i0++) {\n            if (reIndex[iterablesEmptyRows[i0]] !== REMOVED_INDEX) {\n              iterablesEmptyRows[i1] = reIndex[iterablesEmptyRows[i0]];\n              i1++;\n            }\n          }\n\n          iterablesEmptyRows.length = i1;\n\n          for (i0 = 0, i1 = 0; i0 < n; i0++) {\n            if (reIndex[i0] !== REMOVED_INDEX) {\n              if (i1 !== i0) iterablesIndexCount[i1] = iterablesIndexCount[i0];\n              i1++;\n            }\n          }\n\n          iterablesIndexCount = iterablesIndexCount.slice(0, i1);\n        } // Rewrite our index, overwriting removed values\n\n\n        var n0 = values.length;\n\n        for (var i = 0, j = 0, oldDataIndex; i < n0; ++i) {\n          oldDataIndex = index[i];\n\n          if (reIndex[oldDataIndex] !== REMOVED_INDEX) {\n            if (i !== j) values[j] = values[i];\n            index[j] = reIndex[oldDataIndex];\n\n            if (iterable) {\n              iterablesIndexFilterStatus[j] = iterablesIndexFilterStatus[i];\n            }\n\n            ++j;\n          }\n        }\n\n        values.length = j;\n        if (iterable) iterablesIndexFilterStatus = iterablesIndexFilterStatus.slice(0, j);\n\n        while (j < n0) {\n          index[j++] = 0;\n        } // Bisect again to recompute lo0 and hi0.\n\n\n        var bounds = refilter(values);\n        lo0 = bounds[0], hi0 = bounds[1];\n      } // Updates the selected values based on the specified bounds [lo, hi].\n      // This implementation is used by all the public filter methods.\n\n\n      function filterIndexBounds(bounds) {\n        var lo1 = bounds[0],\n            hi1 = bounds[1];\n\n        if (refilterFunction) {\n          refilterFunction = null;\n          filterIndexFunction(function (d, i) {\n            return lo1 <= i && i < hi1;\n          }, bounds[0] === 0 && bounds[1] === values.length);\n          lo0 = lo1;\n          hi0 = hi1;\n          return dimension;\n        }\n\n        var i,\n            j,\n            k,\n            added = [],\n            removed = [],\n            valueIndexAdded = [],\n            valueIndexRemoved = []; // Fast incremental update based on previous lo index.\n\n        if (lo1 < lo0) {\n          for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n            added.push(index[i]);\n            valueIndexAdded.push(i);\n          }\n        } else if (lo1 > lo0) {\n          for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n            removed.push(index[i]);\n            valueIndexRemoved.push(i);\n          }\n        } // Fast incremental update based on previous hi index.\n\n\n        if (hi1 > hi0) {\n          for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n            added.push(index[i]);\n            valueIndexAdded.push(i);\n          }\n        } else if (hi1 < hi0) {\n          for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n            removed.push(index[i]);\n            valueIndexRemoved.push(i);\n          }\n        }\n\n        if (!iterable) {\n          // Flip filters normally.\n          for (i = 0; i < added.length; i++) {\n            filters[offset][added[i]] ^= one;\n          }\n\n          for (i = 0; i < removed.length; i++) {\n            filters[offset][removed[i]] ^= one;\n          }\n        } else {\n          // For iterables, we need to figure out if the row has been completely removed vs partially included\n          // Only count a row as added if it is not already being aggregated. Only count a row\n          // as removed if the last element being aggregated is removed.\n          var newAdded = [];\n          var newRemoved = [];\n\n          for (i = 0; i < added.length; i++) {\n            iterablesIndexCount[added[i]]++;\n            iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n\n            if (iterablesIndexCount[added[i]] === 1) {\n              filters[offset][added[i]] ^= one;\n              newAdded.push(added[i]);\n            }\n          }\n\n          for (i = 0; i < removed.length; i++) {\n            iterablesIndexCount[removed[i]]--;\n            iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n\n            if (iterablesIndexCount[removed[i]] === 0) {\n              filters[offset][removed[i]] ^= one;\n              newRemoved.push(removed[i]);\n            }\n          }\n\n          added = newAdded;\n          removed = newRemoved; // Now handle empty rows.\n\n          if (refilter === xfilterFilter.filterAll) {\n            for (i = 0; i < iterablesEmptyRows.length; i++) {\n              if (filters[offset][k = iterablesEmptyRows[i]] & one) {\n                // Was not in the filter, so set the filter and add\n                filters[offset][k] ^= one;\n                added.push(k);\n              }\n            }\n          } else {\n            // filter in place - remove empty rows if necessary\n            for (i = 0; i < iterablesEmptyRows.length; i++) {\n              if (!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n                // Was in the filter, so set the filter and remove\n                filters[offset][k] ^= one;\n                removed.push(k);\n              }\n            }\n          }\n        }\n\n        lo0 = lo1;\n        hi0 = hi1;\n        filterListeners.forEach(function (l) {\n          l(one, offset, added, removed);\n        });\n        triggerOnChange('filtered');\n        return dimension;\n      } // Filters this dimension using the specified range, value, or null.\n      // If the range is null, this is equivalent to filterAll.\n      // If the range is an array, this is equivalent to filterRange.\n      // Otherwise, this is equivalent to filterExact.\n\n\n      function filter(range) {\n        return range == null ? filterAll() : Array.isArray(range) ? filterRange(range) : typeof range === \"function\" ? filterFunction(range) : filterExact(range);\n      } // Filters this dimension to select the exact value.\n\n\n      function filterExact(value) {\n        filterValue = value;\n        filterValuePresent = true;\n        return filterIndexBounds((refilter = xfilterFilter.filterExact(bisect, value))(values));\n      } // Filters this dimension to select the specified range [lo, hi].\n      // The lower bound is inclusive, and the upper bound is exclusive.\n\n\n      function filterRange(range) {\n        filterValue = range;\n        filterValuePresent = true;\n        return filterIndexBounds((refilter = xfilterFilter.filterRange(bisect, range))(values));\n      } // Clears any filters on this dimension.\n\n\n      function filterAll() {\n        filterValue = undefined;\n        filterValuePresent = false;\n        return filterIndexBounds((refilter = xfilterFilter.filterAll)(values));\n      } // Filters this dimension using an arbitrary function.\n\n\n      function filterFunction(f) {\n        filterValue = f;\n        filterValuePresent = true;\n        refilterFunction = f;\n        refilter = xfilterFilter.filterAll;\n        filterIndexFunction(f, false);\n        var bounds = refilter(values);\n        lo0 = bounds[0], hi0 = bounds[1];\n        return dimension;\n      }\n\n      function filterIndexFunction(f, filterAll) {\n        var i,\n            k,\n            x,\n            added = [],\n            removed = [],\n            valueIndexAdded = [],\n            valueIndexRemoved = [],\n            indexLength = values.length;\n\n        if (!iterable) {\n          for (i = 0; i < indexLength; ++i) {\n            if (!(filters[offset][k = index[i]] & one) ^ !!(x = f(values[i], i))) {\n              if (x) added.push(k);else removed.push(k);\n            }\n          }\n        }\n\n        if (iterable) {\n          for (i = 0; i < indexLength; ++i) {\n            if (f(values[i], i)) {\n              added.push(index[i]);\n              valueIndexAdded.push(i);\n            } else {\n              removed.push(index[i]);\n              valueIndexRemoved.push(i);\n            }\n          }\n        }\n\n        if (!iterable) {\n          for (i = 0; i < added.length; i++) {\n            if (filters[offset][added[i]] & one) filters[offset][added[i]] &= zero;\n          }\n\n          for (i = 0; i < removed.length; i++) {\n            if (!(filters[offset][removed[i]] & one)) filters[offset][removed[i]] |= one;\n          }\n        } else {\n          var newAdded = [];\n          var newRemoved = [];\n\n          for (i = 0; i < added.length; i++) {\n            // First check this particular value needs to be added\n            if (iterablesIndexFilterStatus[valueIndexAdded[i]] === 1) {\n              iterablesIndexCount[added[i]]++;\n              iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n\n              if (iterablesIndexCount[added[i]] === 1) {\n                filters[offset][added[i]] ^= one;\n                newAdded.push(added[i]);\n              }\n            }\n          }\n\n          for (i = 0; i < removed.length; i++) {\n            // First check this particular value needs to be removed\n            if (iterablesIndexFilterStatus[valueIndexRemoved[i]] === 0) {\n              iterablesIndexCount[removed[i]]--;\n              iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n\n              if (iterablesIndexCount[removed[i]] === 0) {\n                filters[offset][removed[i]] ^= one;\n                newRemoved.push(removed[i]);\n              }\n            }\n          }\n\n          added = newAdded;\n          removed = newRemoved; // Now handle empty rows.\n\n          if (filterAll) {\n            for (i = 0; i < iterablesEmptyRows.length; i++) {\n              if (filters[offset][k = iterablesEmptyRows[i]] & one) {\n                // Was not in the filter, so set the filter and add\n                filters[offset][k] ^= one;\n                added.push(k);\n              }\n            }\n          } else {\n            // filter in place - remove empty rows if necessary\n            for (i = 0; i < iterablesEmptyRows.length; i++) {\n              if (!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n                // Was in the filter, so set the filter and remove\n                filters[offset][k] ^= one;\n                removed.push(k);\n              }\n            }\n          }\n        }\n\n        filterListeners.forEach(function (l) {\n          l(one, offset, added, removed);\n        });\n        triggerOnChange('filtered');\n      }\n\n      function currentFilter() {\n        return filterValue;\n      }\n\n      function hasCurrentFilter() {\n        return filterValuePresent;\n      } // Returns the top K selected records based on this dimension's order.\n      // Note: observes this dimension's filter, unlike group and groupAll.\n\n\n      function top(k, top_offset) {\n        var array = [],\n            i = hi0,\n            j,\n            toSkip = 0;\n        if (top_offset && top_offset > 0) toSkip = top_offset;\n\n        while (--i >= lo0 && k > 0) {\n          if (filters.zero(j = index[i])) {\n            if (toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n\n        if (iterable) {\n          for (i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n            // Add row with empty iterable column at the end\n            if (filters.zero(j = iterablesEmptyRows[i])) {\n              if (toSkip > 0) {\n                //skip matching row\n                --toSkip;\n              } else {\n                array.push(data[j]);\n                --k;\n              }\n            }\n          }\n        }\n\n        return array;\n      } // Returns the bottom K selected records based on this dimension's order.\n      // Note: observes this dimension's filter, unlike group and groupAll.\n\n\n      function bottom(k, bottom_offset) {\n        var array = [],\n            i,\n            j,\n            toSkip = 0;\n        if (bottom_offset && bottom_offset > 0) toSkip = bottom_offset;\n\n        if (iterable) {\n          // Add row with empty iterable column at the top\n          for (i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n            if (filters.zero(j = iterablesEmptyRows[i])) {\n              if (toSkip > 0) {\n                //skip matching row\n                --toSkip;\n              } else {\n                array.push(data[j]);\n                --k;\n              }\n            }\n          }\n        }\n\n        i = lo0;\n\n        while (i < hi0 && k > 0) {\n          if (filters.zero(j = index[i])) {\n            if (toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n\n          i++;\n        }\n\n        return array;\n      } // Adds a new group to this dimension, using the specified key function.\n\n\n      function group(key) {\n        var group = {\n          top: top,\n          all: all,\n          reduce: reduce,\n          reduceCount: reduceCount,\n          reduceSum: reduceSum,\n          order: order,\n          orderNatural: orderNatural,\n          size: size,\n          dispose: dispose,\n          remove: dispose // for backwards-compatibility\n\n        }; // Ensure that this group will be removed when the dimension is removed.\n\n        dimensionGroups.push(group);\n        var groups,\n            // array of {key, value}\n        groupIndex,\n            // object id ↦ group id\n        groupWidth = 8,\n            groupCapacity = capacity(groupWidth),\n            k = 0,\n            // cardinality\n        select,\n            heap,\n            reduceAdd,\n            reduceRemove,\n            reduceInitial,\n            update = cr_null,\n            reset = cr_null,\n            resetNeeded = true,\n            groupAll = key === cr_null,\n            n0old;\n        if (arguments.length < 1) key = cr_identity; // The group listens to the crossfilter for when any dimension changes, so\n        // that it can update the associated reduce values. It must also listen to\n        // the parent dimension for when data is added, and compute new keys.\n\n        filterListeners.push(update);\n        indexListeners.push(add);\n        removeDataListeners.push(removeData); // Incorporate any existing data into the grouping.\n\n        add(values, index, 0, n); // Incorporates the specified new values into this group.\n        // This function is responsible for updating groups and groupIndex.\n\n        function add(newValues, newIndex, n0, n1) {\n          if (iterable) {\n            n0old = n0;\n            n0 = values.length - newValues.length;\n            n1 = newValues.length;\n          }\n\n          var oldGroups = groups,\n              reIndex = iterable ? [] : cr_index(k, groupCapacity),\n              add = reduceAdd,\n              remove = reduceRemove,\n              initial = reduceInitial,\n              k0 = k,\n              // old cardinality\n          i0 = 0,\n              // index of old group\n          i1 = 0,\n              // index of new record\n          j,\n              // object id\n          g0,\n              // old group\n          x0,\n              // old key\n          x1,\n              // new key\n          g,\n              // group to add\n          x; // key of group to add\n          // If a reset is needed, we don't need to update the reduce values.\n\n          if (resetNeeded) add = initial = cr_null;\n          if (resetNeeded) remove = initial = cr_null; // Reset the new groups (k is a lower bound).\n          // Also, make sure that groupIndex exists and is long enough.\n\n          groups = new Array(k), k = 0;\n\n          if (iterable) {\n            groupIndex = k0 ? groupIndex : [];\n          } else {\n            groupIndex = k0 > 1 ? xfilterArray.arrayLengthen(groupIndex, n) : cr_index(n, groupCapacity);\n          } // Get the first old key (x0 of g0), if it exists.\n\n\n          if (k0) x0 = (g0 = oldGroups[0]).key; // Find the first new key (x1), skipping NaN keys.\n\n          while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1)) {\n            ++i1;\n          } // While new keys remain…\n\n\n          while (i1 < n1) {\n            // Determine the lesser of the two current keys; new and old.\n            // If there are no old keys remaining, then always add the new key.\n            if (g0 && x0 <= x1) {\n              g = g0, x = x0; // Record the new index of the old group.\n\n              reIndex[i0] = k; // Retrieve the next old key.\n\n              g0 = oldGroups[++i0];\n              if (g0) x0 = g0.key;\n            } else {\n              g = {\n                key: x1,\n                value: initial()\n              }, x = x1;\n            } // Add the lesser group.\n\n\n            groups[k] = g; // Add any selected records belonging to the added group, while\n            // advancing the new key and populating the associated group index.\n\n            while (x1 <= x) {\n              j = newIndex[i1] + (iterable ? n0old : n0);\n\n              if (iterable) {\n                if (groupIndex[j]) {\n                  groupIndex[j].push(k);\n                } else {\n                  groupIndex[j] = [k];\n                }\n              } else {\n                groupIndex[j] = k;\n              } // Always add new values to groups. Only remove when not in filter.\n              // This gives groups full information on data life-cycle.\n\n\n              g.value = add(g.value, data[j], true);\n              if (!filters.zeroExcept(j, offset, zero)) g.value = remove(g.value, data[j], false);\n              if (++i1 >= n1) break;\n              x1 = key(newValues[i1]);\n            }\n\n            groupIncrement();\n          } // Add any remaining old groups that were greater th1an all new keys.\n          // No incremental reduce is needed; these groups have no new records.\n          // Also record the new index of the old group.\n\n\n          while (i0 < k0) {\n            groups[reIndex[i0] = k] = oldGroups[i0++];\n            groupIncrement();\n          } // Fill in gaps with empty arrays where there may have been rows with empty iterables\n\n\n          if (iterable) {\n            for (var index1 = 0; index1 < n; index1++) {\n              if (!groupIndex[index1]) {\n                groupIndex[index1] = [];\n              }\n            }\n          } // If we added any new groups before any old groups,\n          // update the group index of all the old records.\n\n\n          if (k > i0) {\n            if (iterable) {\n              for (i0 = 0; i0 < n0old; ++i0) {\n                for (index1 = 0; index1 < groupIndex[i0].length; index1++) {\n                  groupIndex[i0][index1] = reIndex[groupIndex[i0][index1]];\n                }\n              }\n            } else {\n              for (i0 = 0; i0 < n0; ++i0) {\n                groupIndex[i0] = reIndex[groupIndex[i0]];\n              }\n            }\n          } // Modify the update and reset behavior based on the cardinality.\n          // If the cardinality is less than or equal to one, then the groupIndex\n          // is not needed. If the cardinality is zero, then there are no records\n          // and therefore no groups to update or reset. Note that we also must\n          // change the registered listener to point to the new method.\n\n\n          j = filterListeners.indexOf(update);\n\n          if (k > 1 || iterable) {\n            update = updateMany;\n            reset = resetMany;\n          } else {\n            if (!k && groupAll) {\n              k = 1;\n              groups = [{\n                key: null,\n                value: initial()\n              }];\n            }\n\n            if (k === 1) {\n              update = updateOne;\n              reset = resetOne;\n            } else {\n              update = cr_null;\n              reset = cr_null;\n            }\n\n            groupIndex = null;\n          }\n\n          filterListeners[j] = update; // Count the number of added groups,\n          // and widen the group index as needed.\n\n          function groupIncrement() {\n            if (iterable) {\n              k++;\n              return;\n            }\n\n            if (++k === groupCapacity) {\n              reIndex = xfilterArray.arrayWiden(reIndex, groupWidth <<= 1);\n              groupIndex = xfilterArray.arrayWiden(groupIndex, groupWidth);\n              groupCapacity = capacity(groupWidth);\n            }\n          }\n        }\n\n        function removeData(reIndex) {\n          if (k > 1 || iterable) {\n            var oldK = k,\n                oldGroups = groups,\n                seenGroups = cr_index(oldK, oldK),\n                i,\n                i0,\n                j; // Filter out non-matches by copying matching group index entries to\n            // the beginning of the array.\n\n            if (!iterable) {\n              for (i = 0, j = 0; i < n; ++i) {\n                if (reIndex[i] !== REMOVED_INDEX) {\n                  seenGroups[groupIndex[j] = groupIndex[i]] = 1;\n                  ++j;\n                }\n              }\n            } else {\n              for (i = 0, j = 0; i < n; ++i) {\n                if (reIndex[i] !== REMOVED_INDEX) {\n                  groupIndex[j] = groupIndex[i];\n\n                  for (i0 = 0; i0 < groupIndex[j].length; i0++) {\n                    seenGroups[groupIndex[j][i0]] = 1;\n                  }\n\n                  ++j;\n                }\n              }\n            } // Reassemble groups including only those groups that were referred\n            // to by matching group index entries.  Note the new group index in\n            // seenGroups.\n\n\n            groups = [], k = 0;\n\n            for (i = 0; i < oldK; ++i) {\n              if (seenGroups[i]) {\n                seenGroups[i] = k++;\n                groups.push(oldGroups[i]);\n              }\n            }\n\n            if (k > 1 || iterable) {\n              // Reindex the group index using seenGroups to find the new index.\n              if (!iterable) {\n                for (i = 0; i < j; ++i) {\n                  groupIndex[i] = seenGroups[groupIndex[i]];\n                }\n              } else {\n                for (i = 0; i < j; ++i) {\n                  for (i0 = 0; i0 < groupIndex[i].length; ++i0) {\n                    groupIndex[i][i0] = seenGroups[groupIndex[i][i0]];\n                  }\n                }\n              }\n            } else {\n              groupIndex = null;\n            }\n\n            filterListeners[filterListeners.indexOf(update)] = k > 1 || iterable ? (reset = resetMany, update = updateMany) : k === 1 ? (reset = resetOne, update = updateOne) : reset = update = cr_null;\n          } else if (k === 1) {\n            if (groupAll) return;\n\n            for (var index3 = 0; index3 < n; ++index3) {\n              if (reIndex[index3] !== REMOVED_INDEX) return;\n            }\n\n            groups = [], k = 0;\n            filterListeners[filterListeners.indexOf(update)] = update = reset = cr_null;\n          }\n        } // Reduces the specified selected or deselected records.\n        // This function is only used when the cardinality is greater than 1.\n        // notFilter indicates a crossfilter.add/remove operation.\n\n\n        function updateMany(filterOne, filterOffset, added, removed, notFilter) {\n          if (filterOne === one && filterOffset === offset || resetNeeded) return;\n          var i, j, k, n, g;\n\n          if (iterable) {\n            // Add the added values.\n            for (i = 0, n = added.length; i < n; ++i) {\n              if (filters.zeroExcept(k = added[i], offset, zero)) {\n                for (j = 0; j < groupIndex[k].length; j++) {\n                  g = groups[groupIndex[k][j]];\n                  g.value = reduceAdd(g.value, data[k], false, j);\n                }\n              }\n            } // Remove the removed values.\n\n\n            for (i = 0, n = removed.length; i < n; ++i) {\n              if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n                for (j = 0; j < groupIndex[k].length; j++) {\n                  g = groups[groupIndex[k][j]];\n                  g.value = reduceRemove(g.value, data[k], notFilter, j);\n                }\n              }\n            }\n\n            return;\n          } // Add the added values.\n\n\n          for (i = 0, n = added.length; i < n; ++i) {\n            if (filters.zeroExcept(k = added[i], offset, zero)) {\n              g = groups[groupIndex[k]];\n              g.value = reduceAdd(g.value, data[k], false);\n            }\n          } // Remove the removed values.\n\n\n          for (i = 0, n = removed.length; i < n; ++i) {\n            if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n              g = groups[groupIndex[k]];\n              g.value = reduceRemove(g.value, data[k], notFilter);\n            }\n          }\n        } // Reduces the specified selected or deselected records.\n        // This function is only used when the cardinality is 1.\n        // notFilter indicates a crossfilter.add/remove operation.\n\n\n        function updateOne(filterOne, filterOffset, added, removed, notFilter) {\n          if (filterOne === one && filterOffset === offset || resetNeeded) return;\n          var i,\n              k,\n              n,\n              g = groups[0]; // Add the added values.\n\n          for (i = 0, n = added.length; i < n; ++i) {\n            if (filters.zeroExcept(k = added[i], offset, zero)) {\n              g.value = reduceAdd(g.value, data[k], false);\n            }\n          } // Remove the removed values.\n\n\n          for (i = 0, n = removed.length; i < n; ++i) {\n            if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n              g.value = reduceRemove(g.value, data[k], notFilter);\n            }\n          }\n        } // Recomputes the group reduce values from scratch.\n        // This function is only used when the cardinality is greater than 1.\n\n\n        function resetMany() {\n          var i, j, g; // Reset all group values.\n\n          for (i = 0; i < k; ++i) {\n            groups[i].value = reduceInitial();\n          } // We add all records and then remove filtered records so that reducers\n          // can build an 'unfiltered' view even if there are already filters in\n          // place on other dimensions.\n\n\n          if (iterable) {\n            for (i = 0; i < n; ++i) {\n              for (j = 0; j < groupIndex[i].length; j++) {\n                g = groups[groupIndex[i][j]];\n                g.value = reduceAdd(g.value, data[i], true, j);\n              }\n            }\n\n            for (i = 0; i < n; ++i) {\n              if (!filters.zeroExcept(i, offset, zero)) {\n                for (j = 0; j < groupIndex[i].length; j++) {\n                  g = groups[groupIndex[i][j]];\n                  g.value = reduceRemove(g.value, data[i], false, j);\n                }\n              }\n            }\n\n            return;\n          }\n\n          for (i = 0; i < n; ++i) {\n            g = groups[groupIndex[i]];\n            g.value = reduceAdd(g.value, data[i], true);\n          }\n\n          for (i = 0; i < n; ++i) {\n            if (!filters.zeroExcept(i, offset, zero)) {\n              g = groups[groupIndex[i]];\n              g.value = reduceRemove(g.value, data[i], false);\n            }\n          }\n        } // Recomputes the group reduce values from scratch.\n        // This function is only used when the cardinality is 1.\n\n\n        function resetOne() {\n          var i,\n              g = groups[0]; // Reset the singleton group values.\n\n          g.value = reduceInitial(); // We add all records and then remove filtered records so that reducers\n          // can build an 'unfiltered' view even if there are already filters in\n          // place on other dimensions.\n\n          for (i = 0; i < n; ++i) {\n            g.value = reduceAdd(g.value, data[i], true);\n          }\n\n          for (i = 0; i < n; ++i) {\n            if (!filters.zeroExcept(i, offset, zero)) {\n              g.value = reduceRemove(g.value, data[i], false);\n            }\n          }\n        } // Returns the array of group values, in the dimension's natural order.\n\n\n        function all() {\n          if (resetNeeded) reset(), resetNeeded = false;\n          return groups;\n        } // Returns a new array containing the top K group values, in reduce order.\n\n\n        function top(k) {\n          var top = select(all(), 0, groups.length, k);\n          return heap.sort(top, 0, top.length);\n        } // Sets the reduce behavior for this group to use the specified functions.\n        // This method lazily recomputes the reduce values, waiting until needed.\n\n\n        function reduce(add, remove, initial) {\n          reduceAdd = add;\n          reduceRemove = remove;\n          reduceInitial = initial;\n          resetNeeded = true;\n          return group;\n        } // A convenience method for reducing by count.\n\n\n        function reduceCount() {\n          return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n        } // A convenience method for reducing by sum(value).\n\n\n        function reduceSum(value) {\n          return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n        } // Sets the reduce order, using the specified accessor.\n\n\n        function order(value) {\n          select = h$1.by(valueOf);\n          heap = h.by(valueOf);\n\n          function valueOf(d) {\n            return value(d.value);\n          }\n\n          return group;\n        } // A convenience method for natural ordering by reduce value.\n\n\n        function orderNatural() {\n          return order(cr_identity);\n        } // Returns the cardinality of this group, irrespective of any filters.\n\n\n        function size() {\n          return k;\n        } // Removes this group and associated event listeners.\n\n\n        function dispose() {\n          var i = filterListeners.indexOf(update);\n          if (i >= 0) filterListeners.splice(i, 1);\n          i = indexListeners.indexOf(add);\n          if (i >= 0) indexListeners.splice(i, 1);\n          i = removeDataListeners.indexOf(removeData);\n          if (i >= 0) removeDataListeners.splice(i, 1);\n          i = dimensionGroups.indexOf(group);\n          if (i >= 0) dimensionGroups.splice(i, 1);\n          return group;\n        }\n\n        return reduceCount().orderNatural();\n      } // A convenience function for generating a singleton group.\n\n\n      function groupAll() {\n        var g = group(cr_null),\n            all = g.all;\n        delete g.all;\n        delete g.top;\n        delete g.order;\n        delete g.orderNatural;\n        delete g.size;\n\n        g.value = function () {\n          return all()[0].value;\n        };\n\n        return g;\n      } // Removes this dimension and associated groups and event listeners.\n\n\n      function dispose() {\n        dimensionGroups.forEach(function (group) {\n          group.dispose();\n        });\n        var i = dataListeners.indexOf(preAdd);\n        if (i >= 0) dataListeners.splice(i, 1);\n        i = dataListeners.indexOf(postAdd);\n        if (i >= 0) dataListeners.splice(i, 1);\n        i = removeDataListeners.indexOf(removeData);\n        if (i >= 0) removeDataListeners.splice(i, 1);\n        filters.masks[offset] &= zero;\n        return filterAll();\n      }\n\n      return dimension;\n    } // A convenience method for groupAll on a dummy dimension.\n    // This implementation can be optimized since it always has cardinality 1.\n\n\n    function groupAll() {\n      var group = {\n        reduce: reduce,\n        reduceCount: reduceCount,\n        reduceSum: reduceSum,\n        value: value,\n        dispose: dispose,\n        remove: dispose // for backwards-compatibility\n\n      };\n      var reduceValue,\n          reduceAdd,\n          reduceRemove,\n          reduceInitial,\n          resetNeeded = true; // The group listens to the crossfilter for when any dimension changes, so\n      // that it can update the reduce value. It must also listen to the parent\n      // dimension for when data is added.\n\n      filterListeners.push(update);\n      dataListeners.push(add); // For consistency; actually a no-op since resetNeeded is true.\n\n      add(data, 0); // Incorporates the specified new values into this group.\n\n      function add(newData, n0) {\n        var i;\n        if (resetNeeded) return; // Cycle through all the values.\n\n        for (i = n0; i < n; ++i) {\n          // Add all values all the time.\n          reduceValue = reduceAdd(reduceValue, data[i], true); // Remove the value if filtered.\n\n          if (!filters.zero(i)) {\n            reduceValue = reduceRemove(reduceValue, data[i], false);\n          }\n        }\n      } // Reduces the specified selected or deselected records.\n\n\n      function update(filterOne, filterOffset, added, removed, notFilter) {\n        var i, k, n;\n        if (resetNeeded) return; // Add the added values.\n\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zero(k = added[i])) {\n            reduceValue = reduceAdd(reduceValue, data[k], notFilter);\n          }\n        } // Remove the removed values.\n\n\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.only(k = removed[i], filterOffset, filterOne)) {\n            reduceValue = reduceRemove(reduceValue, data[k], notFilter);\n          }\n        }\n      } // Recomputes the group reduce value from scratch.\n\n\n      function reset() {\n        var i;\n        reduceValue = reduceInitial(); // Cycle through all the values.\n\n        for (i = 0; i < n; ++i) {\n          // Add all values all the time.\n          reduceValue = reduceAdd(reduceValue, data[i], true); // Remove the value if it is filtered.\n\n          if (!filters.zero(i)) {\n            reduceValue = reduceRemove(reduceValue, data[i], false);\n          }\n        }\n      } // Sets the reduce behavior for this group to use the specified functions.\n      // This method lazily recomputes the reduce value, waiting until needed.\n\n\n      function reduce(add, remove, initial) {\n        reduceAdd = add;\n        reduceRemove = remove;\n        reduceInitial = initial;\n        resetNeeded = true;\n        return group;\n      } // A convenience method for reducing by count.\n\n\n      function reduceCount() {\n        return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n      } // A convenience method for reducing by sum(value).\n\n\n      function reduceSum(value) {\n        return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n      } // Returns the computed reduce value.\n\n\n      function value() {\n        if (resetNeeded) reset(), resetNeeded = false;\n        return reduceValue;\n      } // Removes this group and associated event listeners.\n\n\n      function dispose() {\n        var i = filterListeners.indexOf(update);\n        if (i >= 0) filterListeners.splice(i, 1);\n        i = dataListeners.indexOf(add);\n        if (i >= 0) dataListeners.splice(i, 1);\n        return group;\n      }\n\n      return reduceCount();\n    } // Returns the number of records in this crossfilter, irrespective of any filters.\n\n\n    function size() {\n      return n;\n    } // Returns the raw row data contained in this crossfilter\n\n\n    function all() {\n      return data;\n    } // Returns row data with all dimension filters applied, except for filters in ignore_dimensions\n\n\n    function allFiltered(ignore_dimensions) {\n      var array = [],\n          i = 0,\n          mask = maskForDimensions(ignore_dimensions || []);\n\n      for (i = 0; i < n; i++) {\n        if (filters.zeroExceptMask(i, mask)) {\n          array.push(data[i]);\n        }\n      }\n\n      return array;\n    }\n\n    function onChange(cb) {\n      if (typeof cb !== 'function') {\n        /* eslint no-console: 0 */\n        console.warn('onChange callback parameter must be a function!');\n        return;\n      }\n\n      callbacks.push(cb);\n      return function () {\n        callbacks.splice(callbacks.indexOf(cb), 1);\n      };\n    }\n\n    function triggerOnChange(eventName) {\n      for (var i = 0; i < callbacks.length; i++) {\n        callbacks[i](eventName);\n      }\n    }\n\n    return arguments.length ? add(arguments[0]) : crossfilter;\n  } // Returns an array of size n, big enough to store ids up to m.\n\n\n  function cr_index(n, m) {\n    return (m < 0x101 ? xfilterArray.array8 : m < 0x10001 ? xfilterArray.array16 : xfilterArray.array32)(n);\n  } // Constructs a new array of size n, with sequential values from 0 to n - 1.\n\n\n  function cr_range(n) {\n    var range = cr_index(n, n);\n\n    for (var i = -1; ++i < n;) {\n      range[i] = i;\n    }\n\n    return range;\n  }\n\n  function capacity(w) {\n    return w === 8 ? 0x100 : w === 16 ? 0x10000 : 0x100000000;\n  }\n\n  var version = \"1.5.0\"; // Note(cg): exporting current version for umd build.\n\n  crossfilter.version = version;\n  return crossfilter;\n});","map":null,"metadata":{},"sourceType":"script"}